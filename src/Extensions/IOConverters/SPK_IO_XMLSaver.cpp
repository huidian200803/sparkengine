//////////////////////////////////////////////////////////////////////////////////
// SPARK particle engine														//
// Copyright (C) 2008-2011 - Julien Fryer - julienfryer@gmail.com				//
//																				//
// This software is provided 'as-is', without any express or implied			//
// warranty.  In no event will the authors be held liable for any damages		//
// arising from the use of this software.										//
//																				//
// Permission is granted to anyone to use this software for any purpose,		//
// including commercial applications, and to alter it and redistribute it		//
// freely, subject to the following restrictions:								//
//																				//
// 1. The origin of this software must not be misrepresented; you must not		//
//    claim that you wrote the original software. If you use this software		//
//    in a product, an acknowledgment in the product documentation would be		//
//    appreciated but is not required.											//
// 2. Altered source versions must be plainly marked as such, and must not be	//
//    misrepresented as being the original software.							//
// 3. This notice may not be removed or altered from any source distribution.	//
//////////////////////////////////////////////////////////////////////////////////

#include <ctime>

#define TIXML_USE_STL
#include <tinyxml.h>

#include <SPARK_Core.h>
#include "Extensions/IOConverters/SPK_IO_XMLSaver.h"

namespace SPK
{
namespace IO
{
	bool XMLSaver::innerSave(std::ostream& os,Graph& graph) const
	{
		TiXmlDocument doc;

		// Header
		doc.LinkEndChild(new TiXmlDeclaration("1.0","",""));
		time_t currentTime = time(NULL);
		tm* timeinfo = localtime(&currentTime);
		std::string headerComment(" File automatically generated by SPARK on ");
		headerComment += asctime(timeinfo);
		headerComment.replace(headerComment.size() - 1,1,1,' '); // replace the '\n' generated by a space
		doc.LinkEndChild(new TiXmlComment(headerComment.c_str()));

		// Root
		TiXmlElement* root = new TiXmlElement("SPARK");
		doc.LinkEndChild(root);

		Node* node = NULL;
		while ((node = graph.getNextNode()) != NULL)
			if (!node->isProcessed())
				if (!writeNode(*root,*node,graph))
					return false;

		TiXmlPrinter printer;
		printer.SetIndent("\t");
		doc.Accept(&printer);
		os << printer.Str();
		return true;
	}

	bool XMLSaver::writeNode(TiXmlElement& parent,const Node& node,Graph& graph) const
	{
		const Descriptor& desc = node.getDescriptor();

		TiXmlElement* element = new TiXmlElement(desc.getName());
		parent.LinkEndChild(element);

		for (size_t i = 0; i < desc.getNbAttributes(); ++i)
		{
			const Attribute& attrib = desc.getAttribute(i);
			if (attrib.hasValue() && !attrib.isValueOptional())
			{
				if (attrib.getName() == "name")
					element->SetAttribute("name",attrib.getValueString());
				else
				{
					TiXmlElement* child = new TiXmlElement("attrib");
					element->LinkEndChild(child);					
					child->SetAttribute("id",attrib.getName());
					
					switch (attrib.getType())
					{
					case ATTRIBUTE_TYPE_CHAR : 
						child->SetAttribute("value",attrib.getValueChar());
						break;

					case ATTRIBUTE_TYPE_BOOL :
						child->SetAttribute("value",format(attrib.getValueBool()));
						break;

					case ATTRIBUTE_TYPE_INT32 :
						child->SetAttribute("value",format(attrib.getValueInt32()));
						break;

					case ATTRIBUTE_TYPE_UINT32 :
						child->SetAttribute("value",format(attrib.getValueUint32()));
						break;

					case ATTRIBUTE_TYPE_FLOAT :
						child->SetAttribute("value",format(attrib.getValueFloat()));
						break;

					case ATTRIBUTE_TYPE_VECTOR :
						child->SetAttribute("value",format(attrib.getValueVector()));
						break;

					case ATTRIBUTE_TYPE_COLOR :
						child->SetAttribute("value",format(attrib.getValueColor()));
						break;

					case ATTRIBUTE_TYPE_STRING :
						child->SetAttribute("value",attrib.getValueString());
						break;

					case ATTRIBUTE_TYPE_REF : {
						Node* refNode = graph.getNode(attrib.getValueRef());
						if (refNode == NULL)
						{
							SPK_LOG_ERROR("XML ERROR 1");
							return false;
						}
						if (refNode->getNbReferences() > 1)
							child->SetAttribute("ref",format(refNode->getReferenceID()));	
						else if (!writeNode(*child,*refNode,graph))
							return false;
						break; }

					case ATTRIBUTE_TYPE_CHARS :
						child->SetAttribute("value",formatArray(attrib.getValuesChar()));
						break;

					case ATTRIBUTE_TYPE_BOOLS :
						child->SetAttribute("value",formatArray(attrib.getValuesBool()));
						break;

					case ATTRIBUTE_TYPE_INT32S :
						child->SetAttribute("value",formatArray(attrib.getValuesInt32()));
						break;

					case ATTRIBUTE_TYPE_UINT32S :
						child->SetAttribute("value",formatArray(attrib.getValuesUint32()));
						break;

					case ATTRIBUTE_TYPE_FLOATS :
						child->SetAttribute("value",formatArray(attrib.getValuesFloat()));
						break;

					case ATTRIBUTE_TYPE_VECTORS :
						child->SetAttribute("value",formatArray(attrib.getValuesVector()));
						break;

					case ATTRIBUTE_TYPE_COLORS :
						child->SetAttribute("value",formatArray(attrib.getValuesColor()));
						break;

					case ATTRIBUTE_TYPE_STRINGS :
						child->SetAttribute("value",formatArray(attrib.getValuesString()));
						break;

					case ATTRIBUTE_TYPE_REFS : {
						const std::vector<Ref<SPKObject>>& refs = attrib.getValuesRef<SPKObject>();
						for (size_t i = 0; i < refs.size(); ++i)
						{
							Node* refNode = graph.getNode(refs[i]);
							if (refNode == NULL)
							{
								SPK_LOG_ERROR("XML ERROR 2");
								return false;
							}
							if (refNode->getNbReferences() > 1)
							{
								TiXmlElement* ref = new TiXmlElement("Ref");
								ref->SetAttribute("ref",format(refNode->getReferenceID()));
								child->LinkEndChild(ref);
							}
							else if (!writeNode(*child,*refNode,graph))
								return false;	
						}
						break; }

					default :
						SPK_LOG_ERROR("XML ERROR 3");
					}
				}
			}
		}

		if (node.getNbReferences() > 1)
			element->SetAttribute("ref",format(node.getReferenceID()));	
		node.markAsProcessed();
		return true;
	}
}}
